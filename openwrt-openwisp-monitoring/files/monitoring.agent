#!/bin/sh

VERSION=0 #default value of version
COLLECT=0
while [ -n "$1" ]; do
  case "$1" in
    --version|-v) export VERSION=1; break;;
    --url) export BASE_URL="$2"; shift;;
    --uuid) export UUID="$2"; shift;;
    --key) export KEY="$2"; shift;;
    --verify_ssl) export VERIFY_SSL="$2"; shift;;
    --interval) export INTERVAL="$2"; shift;;
    --monitored_interfaces) export MONITORED_INTERFACES="$2"; shift;;
    --verbose_mode) export verbose_mode="$2"; shift;;
    --required_memory) export REQUIRED_PERCENT="$2"; shift;;
    --collect) export COLLECT=1; shift;;
    --max_retries) export MAX_RETRY="$2"; shift;;
    -*)
      echo "Invalid option: $1"
      exit 1
    ;;
    *) break;;
  esac
  shift;
done

if [ "$VERSION" -eq "1" ]; then
  VERSION=$(cat /etc/openwisp/monitoring/VERSION)
  echo "openwisp-monitoring $VERSION"
  exit 0
fi

INTERVAL=${INTERVAL:-300}
verbose_mode=${verbose_mode:-0}
TMP_DIR="/tmp/openwisp/monitoring"

check_available_memory(){
  total=$(ubus call system info | grep -m1 total | tr -cd 0-9)
  available=$(ubus call system info | grep available | tr -cd 0-9)
  required=$(echo - |awk -v percent="$REQUIRED_PERCENT" -v total="$total" '{printf("%.f",percent*total)}')

  if [ "$available" -ge "$required" ]; then
    echo "1"
  else
    [ "$verbose_mode" = "1" ] && logger -s "Not enough memory available" \
                                        -p daemon.err
    echo "0"
  fi
}

collect_data(){
  n=0
  [ "$verbose_mode" = "1" ] && logger -s "Collecting NetJSON Monitoring data" \
                                      -p daemon.info
  until [ "$n" -ge 5 ]
  do
    echo "$(/usr/sbin/netjson_monitoring "$MONITORED_INTERFACES")" && break
    
    if [ "$n" -eq 5 ]; then
      [ "$verbose_mode" = "1" ] && logger -s "Collecting data failed!" \
                                          -p daemon.err
    fi
    n=$((n+1))
    sleep 5
  done
}

set_url_and_curl(){
  if [ -z "$BASE_URL" ]; then
    logger -s "missing required --url option" \
           -t openwisp_monitoring \
           -p daemon.err
    exit 1
  fi

  if [ -z "$UUID" ]; then
    logger -s "missing required --uuid option" \
            -t openwisp_monitoring \
            -p daemon.err
    exit 1
  fi

  if [ -z "$KEY" ]; then
    logger -s "missing required --key option" \
           -t openwisp_monitoring \
           -p daemon.err
    exit 1
  fi

  URL="$BASE_URL/api/v1/monitoring/device/$UUID/?key=$KEY"

  CURL_COMMAND="curl -s -w "%{http_code}""
  [ "$VERIFY_SSL" = "0" ] && CURL_COMMAND="$CURL_COMMAND -k"
  [ "$verbose_mode" = "1" ] && CURL_COMMAND="$CURL_COMMAND -v"
}

save_data() {
  # Remove double quotes from interfaces
  MONITORED_INTERFACES=$(echo "$MONITORED_INTERFACES" | tr -d '"')

  while true
  do
    data="$(collect_data)"
    memory_available="$(check_available_memory)"
    if [ "$memory_available" != "0" ]; then
        file_name="$(date +'%d-%m-%Y_%H:%M:%S').json"
        # make directory
        mkdir -p "$TMP_DIR"
        #save data with file_name
        echo "$data" > "$TMP_DIR/$file_name"
        [ "$verbose_mode" = "1" ] && logger -s "Data saved temporarily" \
                                            -p daemon.info
    fi
    # get process id of container sending data
    pid=$(pgrep -f "openwisp_monitoring.*uuid")
    kill -SIGUSR1 "$pid"
    sleep "$INTERVAL"
  done
}

handle_sigusr1() {
  if [ "$verbose_mode" = "0" ]; then
    logger -s "SIGUSR1 received! Sending data" \
           -t openwisp_monitoring \
           -p daemon.info
  else
    logger -s "SIGUSR1 received! Sending data" \
           -p daemon.info
  fi
}

send_data() {
  while true
  do
    for file in "$TMP_DIR"/*.json
    do
      if [ ! -f "$file" ]; then
        [ "$verbose_mode" = "1" ] && logger -s "No data file found to send." \
                                            -p daemon.info
        trap handle_sigusr1 USR1
        # SIGUSR1 signal received interrupt sleep and continue sending data
        sleep "$INTERVAL" & wait $!
        trap "" USR1
        continue
      fi
      basefilename=${file##*/}
      filename=${basefilename%.*}
      url="$URL&date=$filename"
      data=$(cat "$file")
      # retry sending data in case of failure
      MAX_RETRY=${MAX_RETRY:-5}
      FAILURES=0
      BASE_SECONDS=1
      # check if the data is latest or old one
      [ "$(echo "$TMP_DIR"/*.json | awk '{print $2}')" ] && url="$url&current=true"
      while true
      do
        FAILURES=$((FAILURES+1))
        if [ "$FAILURES" -gt "$MAX_RETRY" ]; then
          if [ "$verbose_mode" = "1" ]; then
            logger -s "Data not sent successfully. Response code is $response_code" \
                   -p daemon.err
          else
            logger -s "Data not sent successfully. Response code is $response_code" \
                   -t openwisp_monitoring \
                   -p daemon.err
          fi

          [ "$verbose_mode" = "0" ] && logger -s "Run with verbose mode to find more." \
                                              -t openwisp_monitoring \
                                              -p daemon.err
          break
        fi
        #send data
        response_code=$($CURL_COMMAND -H "Content-Type: application/json" \
          -d "$data" \
          -v "$url")
        if [ "$response_code" = "200" ]; then
          [ "$verbose_mode" = "1" ] && logger -s "Data sent successfully." \
                                              -p daemon.info
          #Removed saved data
          rm "$file"
          break
        else
          TIME=$((BASE_SECONDS * 2 **(FAILURES-1)))
          [ "$verbose_mode" = "1" ] && logger -s "Data not sent successfully. Retrying after $TIME seconds" \
                                              -p daemon.err
          sleep "$TIME"
        fi
      done
    done
  done
}

if [ "$COLLECT" -eq "1" ]; then
  MONITORED_INTERFACES=${MONITORED_INTERFACES:-*}
  save_data
else
  VERIFY_SSL=${VERIFY_SSL:-0}
  set_url_and_curl && send_data
fi

exit 0
